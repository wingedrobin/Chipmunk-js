<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cpCollision.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arbiter.html">Arbiter</a><ul class='methods'><li data-type='method'><a href="Arbiter.html#applyCachedImpulse">applyCachedImpulse</a></li><li data-type='method'><a href="Arbiter.html#applyImpulse">applyImpulse</a></li><li data-type='method'><a href="Arbiter.html#callSeparate">callSeparate</a></li><li data-type='method'><a href="Arbiter.html#getA">getA</a></li><li data-type='method'><a href="Arbiter.html#getB">getB</a></li><li data-type='method'><a href="Arbiter.html#getContactPointSet">getContactPointSet</a></li><li data-type='method'><a href="Arbiter.html#getDepth">getDepth</a></li><li data-type='method'><a href="Arbiter.html#getNormal">getNormal</a></li><li data-type='method'><a href="Arbiter.html#getPoint">getPoint</a></li><li data-type='method'><a href="Arbiter.html#getShapes">getShapes</a></li><li data-type='method'><a href="Arbiter.html#ignore">ignore</a></li><li data-type='method'><a href="Arbiter.html#isFirstContact">isFirstContact</a></li><li data-type='method'><a href="Arbiter.html#next">next</a></li><li data-type='method'><a href="Arbiter.html#preStep">preStep</a></li><li data-type='method'><a href="Arbiter.html#totalImpulse">totalImpulse</a></li><li data-type='method'><a href="Arbiter.html#totalImpulseWithFriction">totalImpulseWithFriction</a></li><li data-type='method'><a href="Arbiter.html#totalKE">totalKE</a></li><li data-type='method'><a href="Arbiter.html#unthread">unthread</a></li><li data-type='method'><a href="Arbiter.html#update">update</a></li></ul></li><li><a href="circleSegmentQuery.html">circleSegmentQuery</a></li><li><a href="Contact.html">Contact</a></li><li><a href="ContactPoint.html">ContactPoint</a></li><li><a href="cp.BB.html">BB</a></li><li><a href="cp.BBTree.html">BBTree</a><ul class='methods'><li data-type='method'><a href="cp.BBTree.html#collideStatic">collideStatic</a></li><li data-type='method'><a href="cp.BBTree.html#contains">contains</a></li><li data-type='method'><a href="cp.BBTree.html#count">count</a></li><li data-type='method'><a href="cp.BBTree.html#each">each</a></li><li data-type='method'><a href="cp.BBTree.html#getBB">getBB</a></li><li data-type='method'><a href="cp.BBTree.html#getStamp">getStamp</a></li><li data-type='method'><a href="cp.BBTree.html#incrementStamp">incrementStamp</a></li><li data-type='method'><a href="cp.BBTree.html#insert">insert</a></li><li data-type='method'><a href="cp.BBTree.html#log">log</a></li><li data-type='method'><a href="cp.BBTree.html#makeNode">makeNode</a></li><li data-type='method'><a href="cp.BBTree.html#makePair">makePair</a></li><li data-type='method'><a href="cp.BBTree.html#optimize">optimize</a></li><li data-type='method'><a href="cp.BBTree.html#pointQuery">pointQuery</a></li><li data-type='method'><a href="cp.BBTree.html#query">query</a></li><li data-type='method'><a href="cp.BBTree.html#reindex">reindex</a></li><li data-type='method'><a href="cp.BBTree.html#reindexObject">reindexObject</a></li><li data-type='method'><a href="cp.BBTree.html#reindexQuery">reindexQuery</a></li><li data-type='method'><a href="cp.BBTree.html#remove">remove</a></li><li data-type='method'><a href="cp.BBTree.html#segmentQuery">segmentQuery</a></li><li data-type='method'><a href="cp.BBTree.html#subtreeRecycle">subtreeRecycle</a></li></ul></li><li><a href="cp.Body.html">Body</a><ul class='methods'><li data-type='method'><a href="cp.Body.html#addShape">addShape</a></li><li data-type='method'><a href="cp.Body.html#applyForce">applyForce</a></li><li data-type='method'><a href="cp.Body.html#applyImpulse">applyImpulse</a></li><li data-type='method'><a href="cp.Body.html#eachArbiter">eachArbiter</a></li><li data-type='method'><a href="cp.Body.html#eachConstraint">eachConstraint</a></li><li data-type='method'><a href="cp.Body.html#eachShape">eachShape</a></li><li data-type='method'><a href="cp.Body.html#getAngVel">getAngVel</a></li><li data-type='method'><a href="cp.Body.html#getPos">getPos</a></li><li data-type='method'><a href="cp.Body.html#getVel">getVel</a></li><li data-type='method'><a href="cp.Body.html#getVelAtLocalPoint">getVelAtLocalPoint</a></li><li data-type='method'><a href="cp.Body.html#getVelAtPoint">getVelAtPoint</a></li><li data-type='method'><a href="cp.Body.html#getVelAtWorldPoint">getVelAtWorldPoint</a></li><li data-type='method'><a href="cp.Body.html#isRogue">isRogue</a></li><li data-type='method'><a href="cp.Body.html#isSleeping">isSleeping</a></li><li data-type='method'><a href="cp.Body.html#kineticEnergy">kineticEnergy</a></li><li data-type='method'><a href="cp.Body.html#local2World">local2World</a></li><li data-type='method'><a href="cp.Body.html#position_func">position_func</a></li><li data-type='method'><a href="cp.Body.html#removeConstraint">removeConstraint</a></li><li data-type='method'><a href="cp.Body.html#removeShape">removeShape</a></li><li data-type='method'><a href="cp.Body.html#resetForces">resetForces</a></li><li data-type='method'><a href="cp.Body.html#setAngle">setAngle</a></li><li data-type='method'><a href="cp.Body.html#setAngleInternal">setAngleInternal</a></li><li data-type='method'><a href="cp.Body.html#setAngVel">setAngVel</a></li><li data-type='method'><a href="cp.Body.html#setMass">setMass</a></li><li data-type='method'><a href="cp.Body.html#setMoment">setMoment</a></li><li data-type='method'><a href="cp.Body.html#setPos">setPos</a></li><li data-type='method'><a href="cp.Body.html#setVel">setVel</a></li><li data-type='method'><a href="cp.Body.html#velocity_func">velocity_func</a></li><li data-type='method'><a href="cp.Body.html#world2Local">world2Local</a></li></ul></li><li><a href="cp.BoxShape.html">BoxShape</a></li><li><a href="cp.CircleShape.html">CircleShape</a><ul class='methods'><li data-type='method'><a href="cp.CircleShape.html#active">active</a></li><li data-type='method'><a href="cp.CircleShape.html#cacheBB">cacheBB</a></li><li data-type='method'><a href="cp.CircleShape.html#cacheData">cacheData</a></li><li data-type='method'><a href="cp.CircleShape.html#getBB">getBB</a></li><li data-type='method'><a href="cp.CircleShape.html#getBody">getBody</a></li><li data-type='method'><a href="cp.CircleShape.html#nearestPointQuery">nearestPointQuery</a></li><li data-type='method'><a href="cp.CircleShape.html#pointQuery">pointQuery</a></li><li data-type='method'><a href="cp.CircleShape.html#segmentQuery">segmentQuery</a></li><li data-type='method'><a href="cp.CircleShape.html#setBody">setBody</a></li><li data-type='method'><a href="cp.CircleShape.html#setCollisionType">setCollisionType</a></li><li data-type='method'><a href="cp.CircleShape.html#setElasticity">setElasticity</a></li><li data-type='method'><a href="cp.CircleShape.html#setFriction">setFriction</a></li><li data-type='method'><a href="cp.CircleShape.html#setLayers">setLayers</a></li><li data-type='method'><a href="cp.CircleShape.html#setSensor">setSensor</a></li><li data-type='method'><a href="cp.CircleShape.html#update">update</a></li></ul></li><li><a href="cp.CollisionHandler.html">CollisionHandler</a><ul class='methods'><li data-type='method'><a href="cp.CollisionHandler.html#begin">begin</a></li><li data-type='method'><a href="cp.CollisionHandler.html#postSolve">postSolve</a></li><li data-type='method'><a href="cp.CollisionHandler.html#preSolve">preSolve</a></li><li data-type='method'><a href="cp.CollisionHandler.html#separate">separate</a></li></ul></li><li><a href="cp.PolyShape.html">PolyShape</a><ul class='methods'><li data-type='method'><a href="cp.PolyShape.html#active">active</a></li><li data-type='method'><a href="cp.PolyShape.html#cacheBB">cacheBB</a></li><li data-type='method'><a href="cp.PolyShape.html#cacheData">cacheData</a></li><li data-type='method'><a href="cp.PolyShape.html#containsVert">containsVert</a></li><li data-type='method'><a href="cp.PolyShape.html#containsVertPartial">containsVertPartial</a></li><li data-type='method'><a href="cp.PolyShape.html#getBB">getBB</a></li><li data-type='method'><a href="cp.PolyShape.html#getBody">getBody</a></li><li data-type='method'><a href="cp.PolyShape.html#getNumVerts">getNumVerts</a></li><li data-type='method'><a href="cp.PolyShape.html#getVert">getVert</a></li><li data-type='method'><a href="cp.PolyShape.html#nearestPointQuery">nearestPointQuery</a></li><li data-type='method'><a href="cp.PolyShape.html#pointQuery">pointQuery</a></li><li data-type='method'><a href="cp.PolyShape.html#segmentQuery">segmentQuery</a></li><li data-type='method'><a href="cp.PolyShape.html#setBody">setBody</a></li><li data-type='method'><a href="cp.PolyShape.html#setCollisionType">setCollisionType</a></li><li data-type='method'><a href="cp.PolyShape.html#setElasticity">setElasticity</a></li><li data-type='method'><a href="cp.PolyShape.html#setFriction">setFriction</a></li><li data-type='method'><a href="cp.PolyShape.html#setLayers">setLayers</a></li><li data-type='method'><a href="cp.PolyShape.html#setSensor">setSensor</a></li><li data-type='method'><a href="cp.PolyShape.html#setVerts">setVerts</a></li><li data-type='method'><a href="cp.PolyShape.html#transformAxes">transformAxes</a></li><li data-type='method'><a href="cp.PolyShape.html#transformVerts">transformVerts</a></li><li data-type='method'><a href="cp.PolyShape.html#update">update</a></li><li data-type='method'><a href="cp.PolyShape.html#valueOnAxis">valueOnAxis</a></li></ul></li><li><a href="cp.SegmentShape.html">SegmentShape</a><ul class='methods'><li data-type='method'><a href="cp.SegmentShape.html#active">active</a></li><li data-type='method'><a href="cp.SegmentShape.html#cacheBB">cacheBB</a></li><li data-type='method'><a href="cp.SegmentShape.html#cacheData">cacheData</a></li><li data-type='method'><a href="cp.SegmentShape.html#getBB">getBB</a></li><li data-type='method'><a href="cp.SegmentShape.html#getBody">getBody</a></li><li data-type='method'><a href="cp.SegmentShape.html#nearestPointQuery">nearestPointQuery</a></li><li data-type='method'><a href="cp.SegmentShape.html#pointQuery">pointQuery</a></li><li data-type='method'><a href="cp.SegmentShape.html#segmentQuery">segmentQuery</a></li><li data-type='method'><a href="cp.SegmentShape.html#setBody">setBody</a></li><li data-type='method'><a href="cp.SegmentShape.html#setCollisionType">setCollisionType</a></li><li data-type='method'><a href="cp.SegmentShape.html#setElasticity">setElasticity</a></li><li data-type='method'><a href="cp.SegmentShape.html#setEndpoints">setEndpoints</a></li><li data-type='method'><a href="cp.SegmentShape.html#setFriction">setFriction</a></li><li data-type='method'><a href="cp.SegmentShape.html#setLayers">setLayers</a></li><li data-type='method'><a href="cp.SegmentShape.html#setNeighbors">setNeighbors</a></li><li data-type='method'><a href="cp.SegmentShape.html#setSensor">setSensor</a></li><li data-type='method'><a href="cp.SegmentShape.html#update">update</a></li></ul></li><li><a href="cp.Shape.html">Shape</a><ul class='methods'><li data-type='method'><a href="cp.Shape.html#active">active</a></li><li data-type='method'><a href="cp.Shape.html#cacheBB">cacheBB</a></li><li data-type='method'><a href="cp.Shape.html#getBB">getBB</a></li><li data-type='method'><a href="cp.Shape.html#getBody">getBody</a></li><li data-type='method'><a href="cp.Shape.html#pointQuery">pointQuery</a></li><li data-type='method'><a href="cp.Shape.html#setBody">setBody</a></li><li data-type='method'><a href="cp.Shape.html#setCollisionType">setCollisionType</a></li><li data-type='method'><a href="cp.Shape.html#setElasticity">setElasticity</a></li><li data-type='method'><a href="cp.Shape.html#setFriction">setFriction</a></li><li data-type='method'><a href="cp.Shape.html#setLayers">setLayers</a></li><li data-type='method'><a href="cp.Shape.html#setSensor">setSensor</a></li><li data-type='method'><a href="cp.Shape.html#update">update</a></li></ul></li><li><a href="cp.Space.html">Space</a><ul class='methods'><li data-type='method'><a href="cp.Space.html#addBody">addBody</a></li><li data-type='method'><a href="cp.Space.html#addCollisionHandler">addCollisionHandler</a></li><li data-type='method'><a href="cp.Space.html#addConstraint">addConstraint</a></li><li data-type='method'><a href="cp.Space.html#addShape">addShape</a></li><li data-type='method'><a href="cp.Space.html#addStaticShape">addStaticShape</a></li><li data-type='method'><a href="cp.Space.html#containsBody">containsBody</a></li><li data-type='method'><a href="cp.Space.html#containsConstraint">containsConstraint</a></li><li data-type='method'><a href="cp.Space.html#containsShape">containsShape</a></li><li data-type='method'><a href="cp.Space.html#eachBody">eachBody</a></li><li data-type='method'><a href="cp.Space.html#eachConstraint">eachConstraint</a></li><li data-type='method'><a href="cp.Space.html#eachShape">eachShape</a></li><li data-type='method'><a href="cp.Space.html#filterArbiters">filterArbiters</a></li><li data-type='method'><a href="cp.Space.html#getCurrentTimeStep">getCurrentTimeStep</a></li><li data-type='method'><a href="cp.Space.html#isLocked">isLocked</a></li><li data-type='method'><a href="cp.Space.html#lookupHandler">lookupHandler</a></li><li data-type='method'><a href="cp.Space.html#reindexShape">reindexShape</a></li><li data-type='method'><a href="cp.Space.html#reindexShapesForBody">reindexShapesForBody</a></li><li data-type='method'><a href="cp.Space.html#reindexStatic">reindexStatic</a></li><li data-type='method'><a href="cp.Space.html#removeBody">removeBody</a></li><li data-type='method'><a href="cp.Space.html#removeCollisionHandler">removeCollisionHandler</a></li><li data-type='method'><a href="cp.Space.html#removeConstraint">removeConstraint</a></li><li data-type='method'><a href="cp.Space.html#removeShape">removeShape</a></li><li data-type='method'><a href="cp.Space.html#removeStaticShape">removeStaticShape</a></li><li data-type='method'><a href="cp.Space.html#setDefaultCollisionHandler">setDefaultCollisionHandler</a></li><li data-type='method'><a href="cp.Space.html#setIterations">setIterations</a></li><li data-type='method'><a href="cp.Space.html#uncacheArbiter">uncacheArbiter</a></li><li data-type='method'><a href="cp.Space.html#useSpatialHash">useSpatialHash</a></li></ul></li><li><a href="cp.SpatialIndex.html">SpatialIndex</a><ul class='methods'><li data-type='method'><a href="cp.SpatialIndex.html#collideStatic">collideStatic</a></li></ul></li><li><a href="cp.Vect.html">Vect</a><ul class='methods'><li data-type='method'><a href="cp.Vect.html#add">add</a></li><li data-type='method'><a href="cp.Vect.html#mult">mult</a></li><li data-type='method'><a href="cp.Vect.html#neg">neg</a></li><li data-type='method'><a href="cp.Vect.html#project">project</a></li><li data-type='method'><a href="cp.Vect.html#rotate">rotate</a></li><li data-type='method'><a href="cp.Vect.html#sub">sub</a></li></ul></li><li><a href="Leaf.html">Leaf</a><ul class='methods'><li data-type='method'><a href="Leaf.html#addPairs">addPairs</a></li><li data-type='method'><a href="Leaf.html#clearPairs">clearPairs</a></li><li data-type='method'><a href="Leaf.html#containsObj">containsObj</a></li><li data-type='method'><a href="Leaf.html#markLeafQuery">markLeafQuery</a></li><li data-type='method'><a href="Leaf.html#markSubtree">markSubtree</a></li><li data-type='method'><a href="Leaf.html#recycle">recycle</a></li><li data-type='method'><a href="Leaf.html#update">update</a></li></ul></li><li><a href="NearestPointQueryInfo.html">NearestPointQueryInfo</a></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#bbArea">bbArea</a></li><li data-type='method'><a href="Node.html#intersectsBB">intersectsBB</a></li><li data-type='method'><a href="Node.html#markLeafQuery">markLeafQuery</a></li><li data-type='method'><a href="Node.html#markSubtree">markSubtree</a></li><li data-type='method'><a href="Node.html#otherChild">otherChild</a></li><li data-type='method'><a href="Node.html#recycle">recycle</a></li><li data-type='method'><a href="Node.html#replaceChild">replaceChild</a></li><li data-type='method'><a href="Node.html#setA">setA</a></li><li data-type='method'><a href="Node.html#setB">setB</a></li></ul></li><li><a href="Pair.html">Pair</a><ul class='methods'><li data-type='method'><a href="Pair.html#recycle">recycle</a></li></ul></li><li><a href="PointQueryExtendedInfo.html">PointQueryExtendedInfo</a></li><li><a href="SegmentQueryInfo.html">SegmentQueryInfo</a><ul class='methods'><li data-type='method'><a href="SegmentQueryInfo.html#hitDist">hitDist</a></li><li data-type='method'><a href="SegmentQueryInfo.html#hitPoint">hitPoint</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="cp.html">cp</a><ul class='methods'><li data-type='method'><a href="cp.html#.areaForCircle">areaForCircle</a></li><li data-type='method'><a href="cp.html#.areaForPoly">areaForPoly</a></li><li data-type='method'><a href="cp.html#.areaForSegment">areaForSegment</a></li><li data-type='method'><a href="cp.html#.bb">bb</a></li><li data-type='method'><a href="cp.html#.BoxShape2">BoxShape2</a></li><li data-type='method'><a href="cp.html#.centroidForPoly">centroidForPoly</a></li><li data-type='method'><a href="cp.html#.collideShapes">collideShapes</a></li><li data-type='method'><a href="cp.html#.convexHull">convexHull</a></li><li data-type='method'><a href="cp.html#.loopIndexes">loopIndexes</a></li><li data-type='method'><a href="cp.html#.momentForBox">momentForBox</a></li><li data-type='method'><a href="cp.html#.momentForBox2">momentForBox2</a></li><li data-type='method'><a href="cp.html#.momentForCircle">momentForCircle</a></li><li data-type='method'><a href="cp.html#.momentForPoly">momentForPoly</a></li><li data-type='method'><a href="cp.html#.momentForSegment">momentForSegment</a></li><li data-type='method'><a href="cp.html#.recenterPoly">recenterPoly</a></li><li data-type='method'><a href="cp.html#.resetShapeIdCounter">resetShapeIdCounter</a></li><li data-type='method'><a href="cp.html#.v">v</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#assert">assert</a></li><li><a href="global.html#assertSoft">assertSoft</a></li><li><a href="global.html#assertSpaceUnlocked">assertSpaceUnlocked</a></li><li><a href="global.html#bbArea">bbArea</a></li><li><a href="global.html#bbClampVect">bbClampVect</a></li><li><a href="global.html#bbContainsBB">bbContainsBB</a></li><li><a href="global.html#bbContainsVect">bbContainsVect</a></li><li><a href="global.html#bbContainsVect2">bbContainsVect2</a></li><li><a href="global.html#bbExpand">bbExpand</a></li><li><a href="global.html#bbIntersects">bbIntersects</a></li><li><a href="global.html#bbIntersects2">bbIntersects2</a></li><li><a href="global.html#bbIntersectsSegment">bbIntersectsSegment</a></li><li><a href="global.html#bbMerge">bbMerge</a></li><li><a href="global.html#bbMergedArea">bbMergedArea</a></li><li><a href="global.html#bbMergedArea2">bbMergedArea2</a></li><li><a href="global.html#bbNewForCircle">bbNewForCircle</a></li><li><a href="global.html#bbProximity">bbProximity</a></li><li><a href="global.html#bbTreeIntersectsNode">bbTreeIntersectsNode</a></li><li><a href="global.html#bbTreeMergedArea">bbTreeMergedArea</a></li><li><a href="global.html#bbTreeMergedArea2">bbTreeMergedArea2</a></li><li><a href="global.html#bbWrapVect">bbWrapVect</a></li><li><a href="global.html#circle2circle">circle2circle</a></li><li><a href="global.html#circle2circleQuery">circle2circleQuery</a></li><li><a href="global.html#circle2poly">circle2poly</a></li><li><a href="global.html#circle2segment">circle2segment</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clamp01">clamp01</a></li><li><a href="global.html#closestPointOnSegment">closestPointOnSegment</a></li><li><a href="global.html#closestPointOnSegment2">closestPointOnSegment2</a></li><li><a href="global.html#componentActivate">componentActivate</a></li><li><a href="global.html#componentActive">componentActive</a></li><li><a href="global.html#componentAdd">componentAdd</a></li><li><a href="global.html#componentRoot">componentRoot</a></li><li><a href="global.html#CP_MAX_CONTACTS_PER_ARBITER">CP_MAX_CONTACTS_PER_ARBITER</a></li><li><a href="global.html#createStaticBody">createStaticBody</a></li><li><a href="global.html#defaultCollisionHandler">defaultCollisionHandler</a></li><li><a href="global.html#deleteObjFromList">deleteObjFromList</a></li><li><a href="global.html#filterConstraints">filterConstraints</a></li><li><a href="global.html#findMSA">findMSA</a></li><li><a href="global.html#findPointsBehindSeg">findPointsBehindSeg</a></li><li><a href="global.html#findVerts">findVerts</a></li><li><a href="global.html#findVertsFallback">findVertsFallback</a></li><li><a href="global.html#floodFillComponent">floodFillComponent</a></li><li><a href="global.html#hashPair">hashPair</a></li><li><a href="global.html#last_MSA_min">last_MSA_min</a></li><li><a href="global.html#lerp">lerp</a></li><li><a href="global.html#lerpconst">lerpconst</a></li><li><a href="global.html#mymax">mymax</a></li><li><a href="global.html#mymin">mymin</a></li><li><a href="global.html#nodeRender">nodeRender</a></li><li><a href="global.html#nodeSegmentQuery">nodeSegmentQuery</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#numContacts">numContacts</a></li><li><a href="global.html#numLeaves">numLeaves</a></li><li><a href="global.html#numNodes">numNodes</a></li><li><a href="global.html#numPairs">numPairs</a></li><li><a href="global.html#pairInsert">pairInsert</a></li><li><a href="global.html#partitionNodes">partitionNodes</a></li><li><a href="global.html#poly2poly">poly2poly</a></li><li><a href="global.html#polyValidate">polyValidate</a></li><li><a href="global.html#QHullPartition">QHullPartition</a></li><li><a href="global.html#QHullReduce">QHullReduce</a></li><li><a href="global.html#return%257Bboolean%257D">return	{boolean}</a></li><li><a href="global.html#seg2poly">seg2poly</a></li><li><a href="global.html#segValueOnAxis">segValueOnAxis</a></li><li><a href="global.html#shapeIDCounter">shapeIDCounter</a></li><li><a href="global.html#SplittingPlane">SplittingPlane</a></li><li><a href="global.html#subtreeInsert">subtreeInsert</a></li><li><a href="global.html#subtreeQuery">subtreeQuery</a></li><li><a href="global.html#subtreeRemove">subtreeRemove</a></li><li><a href="global.html#subtreeSegmentQuery">subtreeSegmentQuery</a></li><li><a href="global.html#SWAP">SWAP</a></li><li><a href="global.html#unlinkThread">unlinkThread</a></li><li><a href="global.html#unthreadHelper">unthreadHelper</a></li><li><a href="global.html#updateFunc">updateFunc</a></li><li><a href="global.html#vcross2">vcross2</a></li><li><a href="global.html#vdot2">vdot2</a></li><li><a href="global.html#voidQueryFunc">voidQueryFunc</a></li><li><a href="global.html#vzero">vzero</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">cpCollision.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2007 Scott Lembcke
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @var
 * @type	{number}
 * @default	0
 */
var numContacts = 0;

/**
 * @class
 * @param	{cp.Vect}	p
 * @param	{cp.Vect}	n
 * @param	{number}	dist
 * @param	{number}	hash
 */
var Contact = function(p, n, dist, hash)
{
	this.p = p;
	this.n = n;
	this.dist = dist;
	
	this.r1 = this.r2 = vzero;
	this.nMass = this.tMass = this.bounce = this.bias = 0;

	this.jnAcc = this.jtAcc = this.jBias = 0;
	
	this.hash = hash;
	numContacts++;
};

/**
 * @var
 * @type	{array}
 */
var NONE = [];

// Add contact points for circle to circle collisions.
// Used by several collision tests.
/**
 * Add contact points for circle to circle collisions.
 * Used by several collision tests.
 *
 * @function
 * @param	{cp.Vect}	p1
 * @param	{cp.Vect}	p2
 * @param	{number}	r1
 * @param	{number}	r2
 * @return	{Contract}
 */
var circle2circleQuery = function(p1, p2, r1, r2)
{
	var mindist = r1 + r2;
	var delta = vsub(p2, p1);
	var distsq = vlengthsq(delta);
	if(distsq >= mindist*mindist) return;
	
	var dist = Math.sqrt(distsq);

	// Allocate and initialize the contact.
	return new Contact(
		vadd(p1, vmult(delta, 0.5 + (r1 - 0.5*mindist)/(dist ? dist : Infinity))),
		(dist ? vmult(delta, 1/dist) : new Vect(1, 0)),
		dist - mindist,
		0
	);
};

// Collide circle shapes.
/**
 * Collide circle shapes.
 *
 * @function
 * @param	{cp.CircleShape}	circ1
 * @param	{cp.CircleShape}	circ2
 * @return	{Contract[]}
 */
var circle2circle = function(circ1, circ2)
{
	var contact = circle2circleQuery(circ1.tc, circ2.tc, circ1.r, circ2.r);
	return contact ? [contact] : NONE;
};

/**
 * @function
 * @param	{cp.CircleShape}	circleShape
 * @param	{cp.SegmentShape}	segmentShape
 * @return	{Contract[]}	
 */
var circle2segment = function(circleShape, segmentShape)
{
	var seg_a = segmentShape.ta;
	var seg_b = segmentShape.tb;
	var center = circleShape.tc;
	
	var seg_delta = vsub(seg_b, seg_a);
	var closest_t = clamp01(vdot(seg_delta, vsub(center, seg_a))/vlengthsq(seg_delta));
	var closest = vadd(seg_a, vmult(seg_delta, closest_t));
	
	var contact = circle2circleQuery(center, closest, circleShape.r, segmentShape.r);
	if(contact){
		var n = contact.n;
		
		// Reject endcap collisions if tangents are provided.
		return (
			(closest_t === 0 &amp;&amp; vdot(n, segmentShape.a_tangent) &lt; 0) ||
			(closest_t === 1 &amp;&amp; vdot(n, segmentShape.b_tangent) &lt; 0)
		) ? NONE : [contact];
	} else {
		return NONE;
	}
}

/**
 * @var
 * @type	{number}
 * @default	0
 */
var last_MSA_min = 0;

// Find the minimum separating axis for the given poly and axis list.
//
// This function needs to return two values - the index of the min. separating axis and
// the value itself. Short of inlining MSA, returning values through a global like this
// is the fastest implementation.
//
// See: http://jsperf.com/return-two-values-from-function/2
/**
 * Find the minimum separating axis for the given poly and axis list.
 *
 * This function needs to return two values - the index of the min. separating axis and
 * the value itself. Short of inlining MSA, returning values through a global like this
 * is the fastest implementation.
 *
 * See: http://jsperf.com/return-two-values-from-function/2
 *
 * @function
 * @param	{cp.PolyShape}	poly
 * @param	{SplittingPlane}	planes
 * @return	{number}
 */
var findMSA = function(poly, planes)
{
	var min_index = 0;
	var min = poly.valueOnAxis(planes[0].n, planes[0].d);
	if(min > 0) return -1;
	
	for(var i=1; i&lt;planes.length; i++){
		var dist = poly.valueOnAxis(planes[i].n, planes[i].d);
		if(dist > 0) {
			return -1;
		} else if(dist > min){
			min = dist;
			min_index = i;
		}
	}
	
	last_MSA_min = min;
	return min_index;
};

// Add contacts for probably penetrating vertexes.
// This handles the degenerate case where an overlap was detected, but no vertexes fall inside
// the opposing polygon. (like a star of david)
/**
 * Add contacts for probably penetrating vertexes.
 * This handles the degenerate case where an overlap was detected, but no vertexes fall inside
 * the opposing polygon. (like a star of david)
 *
 * @function
 * @param	{cp.PolyShape}	poly1
 * @param	{cp.PolyShape}	poly2
 * @param	{cp.Vect}	n
 * @param	{number}	dist
 * @return	{Contact[]}
 */
var findVertsFallback = function(poly1, poly2, n, dist)
{
	var arr = [];

	var verts1 = poly1.tVerts;
	for(var i=0; i&lt;verts1.length; i+=2){
		var vx = verts1[i];
		var vy = verts1[i+1];
		if(poly2.containsVertPartial(vx, vy, vneg(n))){
			arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i)));
		}
	}
	
	var verts2 = poly2.tVerts;
	for(var i=0; i&lt;verts2.length; i+=2){
		var vx = verts2[i];
		var vy = verts2[i+1];
		if(poly1.containsVertPartial(vx, vy, n)){
			arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i)));
		}
	}
	
	return arr;
};

// Add contacts for penetrating vertexes.
/**
 * Add contacts for penetrating vertexes.
 *
 * @function
 * @param	{cp.PolyShape}	poly1
 * @param	{cp.PolyShape}	poly2
 * @param	{cp.Vect}	n
 * @param	{number}	dist
 * @return	{Contact[]}
 */
var findVerts = function(poly1, poly2, n, dist)
{
	var arr = [];

	var verts1 = poly1.tVerts;
	for(var i=0; i&lt;verts1.length; i+=2){
		var vx = verts1[i];
		var vy = verts1[i+1];
		if(poly2.containsVert(vx, vy)){
			arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i>>1)));
		}
	}
	
	var verts2 = poly2.tVerts;
	for(var i=0; i&lt;verts2.length; i+=2){
		var vx = verts2[i];
		var vy = verts2[i+1];
		if(poly1.containsVert(vx, vy)){
			arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i>>1)));
		}
	}
	
	return (arr.length ? arr : findVertsFallback(poly1, poly2, n, dist));
};

// Collide poly shapes together.
/**
 *  Collide poly shapes together.
 *
 * @function
 * @param	{cp.PolyShape}	poly1
 * @param	{cp.PolyShape}	poly2
 * @return	{Contact[]}
 */
var poly2poly = function(poly1, poly2)
{
	var mini1 = findMSA(poly2, poly1.tPlanes);
	if(mini1 == -1) return NONE;
	var min1 = last_MSA_min;
	
	var mini2 = findMSA(poly1, poly2.tPlanes);
	if(mini2 == -1) return NONE;
	var min2 = last_MSA_min;
	
	// There is overlap, find the penetrating verts
	if(min1 > min2)
		return findVerts(poly1, poly2, poly1.tPlanes[mini1].n, min1);
	else
		return findVerts(poly1, poly2, vneg(poly2.tPlanes[mini2].n), min2);
};

// Like cpPolyValueOnAxis(), but for segments.
/**
 * Like cpPolyValueOnAxis(), but for segments.
 *
 * @function
 * @param	{cp.SegmentShape}	seg
 * @param	{cp.Vect}		n
 * @param	{number}		d
 * @return	{number}
 */
var segValueOnAxis = function(seg, n, d)
{
	var a = vdot(n, seg.ta) - seg.r;
	var b = vdot(n, seg.tb) - seg.r;
	return min(a, b) - d;
};

// Identify vertexes that have penetrated the segment.
/**
 * Identify vertexes that have penetrated the segment.
 *
 * @function
 * @param	{array}	arr
 * @param	{cp.SegmentShape}	seg
 * @param	{cp.PolyShape}		poly
 * @param	{number}			pDist
 * @param	{number}			coef
 */
var findPointsBehindSeg = function(arr, seg, poly, pDist, coef) 
{
	var dta = vcross(seg.tn, seg.ta);
	var dtb = vcross(seg.tn, seg.tb);
	var n = vmult(seg.tn, coef);
	
	var verts = poly.tVerts;
	for(var i=0; i&lt;verts.length; i+=2){
		var vx = verts[i];
		var vy = verts[i+1];
		if(vdot2(vx, vy, n.x, n.y) &lt; vdot(seg.tn, seg.ta)*coef + seg.r){
			var dt = vcross2(seg.tn.x, seg.tn.y, vx, vy);
			if(dta >= dt &amp;&amp; dt >= dtb){
				arr.push(new Contact(new Vect(vx, vy), n, pDist, hashPair(poly.hashid, i)));
			}
		}
	}
};

// This one is complicated and gross. Just don't go there...
// TODO: Comment me!
/**
 * This one is complicated and gross. Just don't go there...
 *
 * @function
 * @todo	Comment me!
 * @param	{cp.SegmentShape}	seg
 * @param	{cp.PolyShape}	poly
 * @return	{Contact[]}
 */
var seg2poly = function(seg, poly)
{
	var arr = [];

	var planes = poly.tPlanes;
	var numVerts = planes.length;
	
	var segD = vdot(seg.tn, seg.ta);
	var minNorm = poly.valueOnAxis(seg.tn, segD) - seg.r;
	var minNeg = poly.valueOnAxis(vneg(seg.tn), -segD) - seg.r;
	if(minNeg > 0 || minNorm > 0) return NONE;
	
	var mini = 0;
	var poly_min = segValueOnAxis(seg, planes[0].n, planes[0].d);
	if(poly_min > 0) return NONE;
	for(var i=0; i&lt;numVerts; i++){
		var dist = segValueOnAxis(seg, planes[i].n, planes[i].d);
		if(dist > 0){
			return NONE;
		} else if(dist > poly_min){
			poly_min = dist;
			mini = i;
		}
	}
	
	var poly_n = vneg(planes[mini].n);
	
	var va = vadd(seg.ta, vmult(poly_n, seg.r));
	var vb = vadd(seg.tb, vmult(poly_n, seg.r));
	if(poly.containsVert(va.x, va.y))
		arr.push(new Contact(va, poly_n, poly_min, hashPair(seg.hashid, 0)));
	if(poly.containsVert(vb.x, vb.y))
		arr.push(new Contact(vb, poly_n, poly_min, hashPair(seg.hashid, 1)));
	
	// Floating point precision problems here.
	// This will have to do for now.
//	poly_min -= cp_collision_slop; // TODO is this needed anymore?
	
	if(minNorm >= poly_min || minNeg >= poly_min) {
		if(minNorm > minNeg)
			findPointsBehindSeg(arr, seg, poly, minNorm, 1);
		else
			findPointsBehindSeg(arr, seg, poly, minNeg, -1);
	}
	
	// If no other collision points are found, try colliding endpoints.
	if(arr.length === 0){
		var mini2 = mini * 2;
		var verts = poly.tVerts;

		var poly_a = new Vect(verts[mini2], verts[mini2+1]);
		
		var con;
		if((con = circle2circleQuery(seg.ta, poly_a, seg.r, 0, arr))) return [con];
		if((con = circle2circleQuery(seg.tb, poly_a, seg.r, 0, arr))) return [con];

		var len = numVerts * 2;
		var poly_b = new Vect(verts[(mini2+2)%len], verts[(mini2+3)%len]);
		if((con = circle2circleQuery(seg.ta, poly_b, seg.r, 0, arr))) return [con];
		if((con = circle2circleQuery(seg.tb, poly_b, seg.r, 0, arr))) return [con];
	}

//	console.log(poly.tVerts, poly.tPlanes);
//	console.log('seg2poly', arr);
	return arr;
};

// This one is less gross, but still gross.
// TODO: Comment me!
/**
 * This one is less gross, but still gross.
 *
 * @function
 * @todo	Comment me!
 * @param	{cp.CircleShape}	circ
 * @param	{cp.PolyShape}		poly
 * @return	{Contact[]}
 */
var circle2poly = function(circ, poly)
{
	var planes = poly.tPlanes;
	
	var mini = 0;
	var min = vdot(planes[0].n, circ.tc) - planes[0].d - circ.r;
	for(var i=0; i&lt;planes.length; i++){
		var dist = vdot(planes[i].n, circ.tc) - planes[i].d - circ.r;
		if(dist > 0){
			return NONE;
		} else if(dist > min) {
			min = dist;
			mini = i;
		}
	}
	
	var n = planes[mini].n;

	var verts = poly.tVerts;
	var len = verts.length;
	var mini2 = mini&lt;&lt;1;

	//var a = poly.tVerts[mini];
	//var b = poly.tVerts[(mini + 1)%poly.tVerts.length];
	var ax = verts[mini2];
	var ay = verts[mini2+1];
	var bx = verts[(mini2+2)%len];
	var by = verts[(mini2+3)%len];

	var dta = vcross2(n.x, n.y, ax, ay);
	var dtb = vcross2(n.x, n.y, bx, by);
	var dt = vcross(n, circ.tc);
		
	if(dt &lt; dtb){
		var con = circle2circleQuery(circ.tc, new Vect(bx, by), circ.r, 0, con);
		return con ? [con] : NONE;
	} else if(dt &lt; dta) {
		return [new Contact(
			vsub(circ.tc, vmult(n, circ.r + min/2)),
			vneg(n),
			min,
			0
		)];
	} else {
		var con = circle2circleQuery(circ.tc, new Vect(ax, ay), circ.r, 0, con);
		return con ? [con] : NONE;
	}
};

// The javascripty way to do this would be either nested object or methods on the prototypes.
// 
// However, the *fastest* way is the method below.
// See: http://jsperf.com/dispatch

// These are copied from the prototypes into the actual objects in the Shape constructor.

/**
 * @constant	{number}
 * @memberof	cp.CircleShape
 */
CircleShape.prototype.collisionCode = 0;

/**
 * @constant	{number}
 * @memberof	cp.SegmentShape
 */
SegmentShape.prototype.collisionCode = 1;

/**
 * @constant	{number}
 * @memberof	cp.PolyShape
 */
PolyShape.prototype.collisionCode = 2;

/**
 * @constant	{function[]}
 * @memberof	cp.CircleShape
 */
CircleShape.prototype.collisionTable = [
	circle2circle,
	circle2segment,
	circle2poly
];

/**
 * @constant	{function[]}
 * @memberof	cp.SegmentShape
 */
SegmentShape.prototype.collisionTable = [
	null,
	function(segA, segB) { return NONE; }, // seg2seg
	seg2poly
];

/**
 * @constant	{function[]}
 * @memberof	cp.PolyShape
 */
PolyShape.prototype.collisionTable = [
	null,
	null,
	poly2poly
];

/**
 * @function
 * @memberof	cp
 * @param	{cp.Shape}	a
 * @param	{cp.Shape}	b
 * @return	{Contact[]}	
 */
var collideShapes = cp.collideShapes = function(a, b)
{
	assert(a.collisionCode &lt;= b.collisionCode, 'Collided shapes must be sorted by type');
	return a.collisionTable[b.collisionCode](a, b);
};

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Sat Jul 23 2016 01:10:36 GMT+0800 (TST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
